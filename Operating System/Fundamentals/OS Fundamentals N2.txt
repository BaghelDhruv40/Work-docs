-> It will not be wrong to say OS is literally a system for operating the hardware. But why do we need a system to operate hardware?

-> Let's first clarify what a computer is. We do have many perspectives on the term "computer". A computer is anything that computes. Here, we will talk about machine. A machine computer can be further classified as mechanical and electrical. Mechanical computers is itself an interesting topic of study, but, we further narrow down to electrical computers. Now electrical computers can be further classified as analog and digital. So we will be focusing on digital computers and will refer them only as computers here.

-> The brain of a computer is called CPU. Once we have developed that, we have made an achievement. But, the brain need not only computes but identify, control and coordinate also. Even if being able to compute, the brain must be able to receive input. It may just identify that the input has been given or able to fetch from a location. Okay, identifying the input is easy. We are at hardware level and in the electrical environment and so detection of current or potential difference by electrical components is what referred as identifying the input.

Now think of it. If every instruction is modulated into some numbers, the CPU can perform the computations over it and achieve the desired task. Letting the CPU to just identify the inputs means explicitly providing the inputs to it. Without providing the inputs, the CPU is in ideal state.

Important fact to capture from here is that instructions to be perform are evaluated by CPU. CPU is not just a brain for calculations, instead, we have found the ways to perform any task by first modulating it into mathematical terms and let the brain operate on it to produce the output. This clears the role of CPU in computers. CPU indeed have two parts: ALU, CU.

-> CU of the CPU is the controller/instructor for the ALU. Whatever ALU has to recieve and has to give, it goes through and to CU first. CU doesn't have thinking ability. Whatever instruction is given as an input, CU just pass it correctly to ALU and the output when recieved by CU, based on that, it perform the next thing. It is not wrong the say ALU is the actual unit performing decision making. ALU does interact with CU. Being so un-biased and dumb, it can't control and coordinate creatively. What we can do is, we provide instructions to ALU and then ALU tells (based on the output) CU what to do. And here comes OS. OS is our code that is executed by CU, operated by ALU and then in result instruct CU what to do. OS is just an important member here. It is the scheduler/manager for CU. Hence, we can't let any other process have more priority than OS so that OS is always in the memory and running. But OS can't be always running in a single core system. This because, the CPU can operate on a single process only and if OS is already incharge, other process can't be executed. In such case what OS actually does is that it saves its own context and set a way so CU automatically calls the OS again. Hence OS itself save its context and comes back later.

In much simpler way, external components (out of CPU) are not talking to CU directly. The CPU just working on loaded OS. Hence, OS is always running. Now, whatever external components exist must contact with OS and not CU. The access to CU is kept secured by system manufacturers and only permitted components can directly contact with CU. One of them must be that component which instruct CU to load and run OS. After that, everything is build over OS only and hence has OS act as a guard for CU. CU cares about only instructions for ALU to execute. It doesn't care about the source of those instructions.



