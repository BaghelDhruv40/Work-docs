PROBLEMS ON BINARY TREE
-----------------------

-> Binary tree is an important data structure that can be used as a way to depict decision making at every point.

    PROBLEMS ON BINARY TREE CREATION
    --------------------------------

    -> So, the very first problem is how to even create a binary tree? A binary tree has three members: root or parent, left and right children and leaf nodes.

    -> The recursive defintion of binary tree is like this: A data structure with a root such that the root can have at most two sub trees. This definition emphasize that how important is the root.

    -> We can use this knowledge of knowing the root node to recursively create the whole binary tree.

        INPUT AS AN ARRAY
        -----------------

        -> When input is given as array, we can use indices to iterate over it as the tree is building.

        -> If we consider the very first index element to be root, we can recursively build tree as parent-> left -> right. This order is called preorder.

        -> let's first create a basic node structure of the binary tree:

            PYTHON CODE:

                class TreeNode:

                    def __init__(self,val=None):

                        self.val=val
                        self.left=None
                        self.right=None

        -> Now we can work on building tree.

            PREORDER APPROACH
            -----------------

            -> Once we get our root element, we have to first assign its left child.

            -> Say we are at idx=1. If this element is not null, we can assign this to the left child.

            -> Once done, we have to go to idx=2. Which node have to assigned at this point? The answer is again the left child of the previously assigned node.

            -> We can keep going this way and keep assigning left childs of previously assigned node until we meet a null node in the input array. At this point, we must assign the right child of the previously assigned node.

            -> Once assigned, we again keep assigning the left children.

            -> We will only go back to previously assigned node, to assign its right child, when we meet a null node. And if we meet two consecutive null nodes in the input array, that would mean the previously assigned node is a leaf node. And so we must go back to the parent of the leaf node to assign its right child.

            -> Hence, this is the summarized procedure:

                -> Assign arr[idx=0] as the root.
                -> Assign arr[idx=1] as its left child only if not null.
                -> Keep incrementing the idx and assign the left chil until not find a null value.
                -> Once null value is find, increment idx by one and assign right child of te previously assigned node, if not null.
                -> If two consecutive null nodes found in arr, the previously assigned node becomes leaf node and we have to go back to its parent to continue the above steps in sequence.
                -> Repeat these steps unless the idx>=len(arr). Once reached, just return back.

            
                IMPLEMENTATION
                --------------

                    PYTHON CODE:

                    # APPROACH 1: BRUTE FORCE

                    arr=[] # Input array
                    idx=0 # Denotes current element index

                    def BuildTreeRoot():
                        return TreeNode(arr[idx])

                    def BuildTree():
                        global idx
                        if idx>=len(arr):
                            return

                        return TreeNode(arr[idx])

                    root = BuildTreeRoot()


                    def preOrderBuild(node):
                        global idx
                        idx+=1
                        if idx>=len(arr):
                            return

                        if node:
                            if node.left is None:
                                node.left=BuildTree()
                                preOrderBuild(node.left)

                            if node.right is None:
                                node.right=BuildTree()
                                preOrderBuild(node.right)

                    preOrderBuild(root)


                    # APPROACH 2: BETTER

                    arr=[] # Input array
                    idx=0 # array current element index

                    def preOrderBuild():

                        global idx
                        idx+=1

                        if idx>=len(arr):
                            return

                        node=TreeNode(arr[idx])
                        node.left=preOrderBuild()
                        node.right=preOrderBuild()
                        return node

                    root=preOrderBuild()


PROBLEMS ON BINARY SEARCH TREE
------------------------------

-> BST is an important type of BT that can be used in the implementation of many other datastructures, like dictionary.

-> BST obey an order. The left child value must be less than the parent's value, and, the parent's value must be less than its right child value.

-> While creating a BST, we have to obey this order.

    PROBLEMS ON CREATION OF BST
    ---------------------------

